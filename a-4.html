<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Word Search éŠæˆ²</title>

<style>
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
  text-align: center;
  background: #f6f7fb;
  margin: 0;
  padding: 20px;
}

h1 { margin-bottom: 10px; }

button {
  padding: 10px 18px;
  margin: 6px;
  font-size: 16px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: white;
}

button:active { transform: scale(0.97); }

#menu, #game { max-width: 420px; margin: auto; }

#grid {
  display: grid;
  gap: 4px;
  margin: 20px auto;
  touch-action: none;
}

.cell {
  width: 44px;
  height: 44px;
  background: white;
  border-radius: 6px;
  font-size: 20px;
  font-weight: bold;
  display: flex;
  justify-content: center;
  align-items: center;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}

.cell.active { background: #fde68a; }
.cell.found { background: #86efac; }

#words span {
  display: inline-block;
  margin: 4px 8px;
  font-weight: bold;
}

#win {
  display: none;
  font-size: 26px;
  animation: pop 0.8s ease;
}

@keyframes pop {
  0% { transform: scale(0.5); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}
</style>
</head>

<body>

<h1>ğŸ” Word Search</h1>

<div id="menu">
  <p>é¸æ“‡é—œå¡</p>
  <button onclick="startLevel('junior')">åœ‹ä¸­æœƒè€ƒ</button>
  <button onclick="startLevel('senior')">é«˜ä¸­å­¸æ¸¬</button>
  <button onclick="startLevel('custom')">è‡ªè¨‚é¡Œç›®</button>
</div>

<div id="game" style="display:none;">
  <div id="grid"></div>
  <div id="words"></div>
  <div id="win">ğŸ‰ å…¨éƒ¨å®Œæˆï¼</div>
  <button onclick="backMenu()">è¿”å›é¸å–®</button>
</div>

<script>
/* ===== è³‡æ–™ ===== */
const levels = {
  junior: ["BOOK", "READ", "WORD"],
  senior: ["ANALYSIS", "CONTEXT", "SYNTAX"]
};

let gridSize = 8;
let words = [];
let found = new Set();
let grid = [];
let selecting = false;
let startCell = null;
let path = [];

let audioCtx;

/* ===== éŸ³æ•ˆ ===== */
function beep(freq, dur=0.15) {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.frequency.value = freq;
  o.connect(g);
  g.connect(audioCtx.destination);
  g.gain.value = 0.1;
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

/* ===== é–‹å§‹é—œå¡ ===== */
function startLevel(type) {
  document.getElementById("menu").style.display = "none";
  document.getElementById("game").style.display = "block";
  document.getElementById("win").style.display = "none";
  found.clear();

  if (type === "custom") {
    const input = prompt("è¼¸å…¥å–®å­—ï¼ˆç”¨é€—è™Ÿåˆ†éš”ï¼‰");
    words = input ? input.toUpperCase().split(",") : [];
  } else {
    words = levels[type];
  }

  initGrid();
  renderWords();
}

/* ===== å»ºç«‹æ£‹ç›¤ ===== */
function initGrid() {
  grid = Array(gridSize * gridSize).fill("");
  words.forEach((word, i) => {
    for (let j = 0; j < word.length; j++) {
      grid[i * gridSize + j] = word[j];
    }
  });
  for (let i = 0; i < grid.length; i++) {
    if (!grid[i]) grid[i] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
  }
  renderGrid();
}

/* ===== ç•«é¢ ===== */
function renderGrid() {
  const g = document.getElementById("grid");
  g.innerHTML = "";
  g.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

  grid.forEach((l, i) => {
    const d = document.createElement("div");
    d.className = "cell";
    d.textContent = l;
    d.dataset.i = i;

    d.onpointerdown = () => startSelect(d);
    d.onpointerenter = () => moveSelect(d);
    d.onpointerup = endSelect;

    g.appendChild(d);
  });
}

function renderWords() {
  const w = document.getElementById("words");
  w.innerHTML = "";
  words.forEach(word => {
    const s = document.createElement("span");
    s.textContent = word;
    s.id = "w_" + word;
    w.appendChild(s);
  });
}

/* ===== é¸å­—é‚è¼¯ï¼ˆç›´ç·šï¼‰ ===== */
function startSelect(cell) {
  selecting = true;
  startCell = cell;
  path = [cell];
  cell.classList.add("active");
  beep(600, 0.05);
}

function moveSelect(cell) {
  if (!selecting) return;
  clearActive();
  path = getLine(startCell, cell);
  path.forEach(c => c.classList.add("active"));
}

function endSelect() {
  if (!selecting) return;
  selecting = false;

  const word = path.map(c => c.textContent).join("");
  if (words.includes(word) && !found.has(word)) {
    found.add(word);
    path.forEach(c => {
      c.classList.remove("active");
      c.classList.add("found");
    });
    document.getElementById("w_" + word).style.textDecoration = "line-through";
    beep(900);
  } else {
    clearActive();
  }

  if (found.size === words.length) win();
}

/* ===== è¼”åŠ© ===== */
function clearActive() {
  document.querySelectorAll(".cell").forEach(c => c.classList.remove("active"));
}

function getLine(a, b) {
  const ai = +a.dataset.i, bi = +b.dataset.i;
  const ax = ai % gridSize, ay = Math.floor(ai / gridSize);
  const bx = bi % gridSize, by = Math.floor(bi / gridSize);

  const dx = Math.sign(bx - ax);
  const dy = Math.sign(by - ay);

  if (!(dx === 0 || dy === 0 || Math.abs(bx - ax) === Math.abs(by - ay))) return [a];

  const cells = [];
  let x = ax, y = ay;
  while (true) {
    cells.push(document.querySelector(`.cell[data-i='${y * gridSize + x}']`));
    if (x === bx && y === by) break;
    x += dx; y += dy;
  }
  return cells;
}

function win() {
  document.getElementById("win").style.display = "block";
  beep(1200, 0.3);
}

function backMenu() {
  document.getElementById("game").style.display = "none";
  document.getElementById("menu").style.display = "block";
}
</script>

</body>
</html>
